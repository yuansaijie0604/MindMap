# å›æº¯

## ç›®å½•

* [æ¡†æ¶](#æ¡†æ¶)

* [æ£‹ç›˜](#æ£‹ç›˜)

    *   [51. N çš‡å](#51-n-çš‡å)

    *   [37. è§£æ•°ç‹¬](#37-è§£æ•°ç‹¬)

*   [æ’åˆ—](#æ’åˆ—)

    *   [46. å…¨æ’åˆ—](#46-å…¨æ’åˆ—)
    
    *   [47. å…¨æ’åˆ— II](#47-å…¨æ’åˆ—-ii)
    
*   [å­é›†](#å­é›†)

    *   [78. å­é›†](#78-å­é›†)

    *   [90. å­é›† II](#90-å­é›†-ii)

*   [ç»„åˆ](#ç»„åˆ)

    *   [77. ç»„åˆ](#77-ç»„åˆ)

    *   [39. ç»„åˆæ€»å’Œ](#39-ç»„åˆæ€»å’Œ)

    *   [40. ç»„åˆæ€»å’Œ II](#40-ç»„åˆæ€»å’Œ-ii)

    *   [216. ç»„åˆæ€»å’Œ III](#216-ç»„åˆæ€»å’Œ-iii)

    *   [17. ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](#17-ç”µè¯å·ç çš„å­—æ¯ç»„åˆ)

*   [åˆ‡å‰²](#åˆ‡å‰²)

    *   [131. åˆ†å‰²å›æ–‡ä¸²](#131-åˆ†å‰²å›æ–‡ä¸²)

    *   [93. å¤åŸ IP åœ°å€](#93-å¤åŸ-ip-åœ°å€)

    *   [698. åˆ’åˆ†ä¸ºkä¸ªç›¸ç­‰çš„å­é›†](#698-åˆ’åˆ†ä¸ºkä¸ªç›¸ç­‰çš„å­é›†)

*   [å…¶ä»–](#å…¶ä»–)

    *   [22. æ‹¬å·ç”Ÿæˆ](#22-æ‹¬å·ç”Ÿæˆ)

    *   [491. é€’å¢å­åºåˆ—](#491-é€’å¢å­åºåˆ—)

    *   [332. é‡æ–°å®‰æ’è¡Œç¨‹](#332-é‡æ–°å®‰æ’è¡Œç¨‹)

## æ¡†æ¶

```çº¯æ–‡æœ¬
result = []
def backtrack(è·¯å¾„, é€‰æ‹©åˆ—è¡¨):
    if æ»¡è¶³ç»“æŸæ¡ä»¶:
        result.add(è·¯å¾„)
        return

    for é€‰æ‹© in é€‰æ‹©åˆ—è¡¨:
        åšé€‰æ‹©
        backtrack(è·¯å¾„, é€‰æ‹©åˆ—è¡¨)
        æ’¤é”€é€‰æ‹©
```

*   ç»„åˆé—®é¢˜ï¼šNä¸ªæ•°é‡Œé¢æŒ‰ä¸€å®šè§„åˆ™æ‰¾å‡ºkä¸ªæ•°çš„é›†åˆ

*   åˆ‡å‰²é—®é¢˜ï¼šä¸€ä¸ªå­—ç¬¦ä¸²æŒ‰ä¸€å®šè§„åˆ™æœ‰å‡ ç§åˆ‡å‰²æ–¹å¼

*   å­é›†é—®é¢˜ï¼šä¸€ä¸ªNä¸ªæ•°çš„é›†åˆé‡Œæœ‰å¤šå°‘ç¬¦åˆæ¡ä»¶çš„å­é›†

*   æ’åˆ—é—®é¢˜ï¼šNä¸ªæ•°æŒ‰ä¸€å®šè§„åˆ™å…¨æ’åˆ—ï¼Œæœ‰å‡ ç§æ’åˆ—æ–¹å¼

*   æ£‹ç›˜é—®é¢˜ï¼šNçš‡åï¼Œè§£æ•°ç‹¬ç­‰ç­‰

# æ£‹ç›˜

#### 51. N çš‡å

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        res = []

        def get_queen(track):
            if len(track) == n:
                res.append(self.draw_chess(track[:]))
            
            for i in range(n):
                if not self.is_valid(track, i):
                    continue
                track.append(i)
                get_queen(track)
                track.pop(-1)
                
        get_queen([])

        return res


    def is_valid(self, track, idx) -> bool:
        if idx in track:
            return False

        len_ = len(track)
        for i, x in enumerate(track):
            if idx in [x-len_+i, x+len_-i]:
                return False

        return True


    def draw_chess(self, track):
        result = []
        len_ = len(track)
        for t in track:
            result.append("."*t + "Q" + "."*(len_-t-1))
        return result
```

#### 37. è§£æ•°ç‹¬

```python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        def dfs(board, sr, sc):
            if sr == 9: return True
            if sc == 9:
                return dfs(board, sr+1, 0)
            if board[sr][sc] != '.':
                return dfs(board, sr, sc+1)
            
            for i in range(1, 10):
                if not is_valid(str(i), sr, sc, board):
                    continue
                board[sr][sc] = str(i)
                if dfs(board, sr, sc+1):
                    return True
                
                board[sr][sc] = '.'

            return False

        def is_valid(n, row, col, track):
            for i in range(9):
                if track[row][i] == n: return False
                if track[i][col] == n: return False
                if track[int(row/3)*3+int(i/3)][int(col/3)*3+i%3] == n: return False
            return True

        dfs(board, 0, 0)
```

# æ’åˆ—

#### 46. å…¨æ’åˆ—

é¢˜ç›®æè¿°ï¼šç»™å®šä¸€ä¸ªä¸å«é‡å¤æ•°å­—çš„æ•°ç»„ `nums` ï¼Œè¿”å›å…¶ **æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ—** ã€‚ä½ å¯ä»¥ **æŒ‰ä»»æ„é¡ºåº** è¿”å›ç­”æ¡ˆã€‚

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []

        def dfs(nums, track):
            if len(track) == len(nums):
                res.append(track[:])

            for i in range(len(nums)):
                if nums[i] in track:
                    continue
                track.append(nums[i])
                dfs(nums, track)
                track.pop(-1)

        dfs(nums, [])

        return res

```

#### 47. å…¨æ’åˆ— II

é¢˜ç›®æè¿°ï¼šç»™å®šä¸€ä¸ªå¯åŒ…å«é‡å¤æ•°å­—çš„åºåˆ— `nums` ï¼Œ**æŒ‰ä»»æ„é¡ºåº** è¿”å›æ‰€æœ‰ä¸é‡å¤çš„å…¨æ’åˆ—ã€‚

é¢˜è§£ï¼šæŠŠåºåˆ—æ’åºï¼Œä»å·¦å¾€å³å¡«ï¼Œå¡«è¿‡çš„åšè®°å½•ã€‚

![](image/image_7Oz5OGDS07.png)

```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        used = [False]*len(nums)

        def dfs(track):
            if len(track) == len(nums):
                res.append(track[:])
            
            for i in range(len(nums)):
                if used[i]==True: continue
                if i>0 and nums[i]==nums[i-1] and used[i-1]==False:
                    continue
                used[i]=True
                track.append(nums[i])
                dfs(track)
                track.pop(-1)
                used[i]=False

        dfs([])
        return res

```

# å­é›†

> ğŸ“Œ**å­é›†æ˜¯æ”¶é›†æ ‘å½¢ç»“æ„ä¸­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹çš„ç»“æœ**ã€‚
> **è€Œç»„åˆé—®é¢˜ã€åˆ†å‰²é—®é¢˜æ˜¯æ”¶é›†æ ‘å½¢ç»“æ„ä¸­å¶å­èŠ‚ç‚¹çš„ç»“æœ**ã€‚

#### 78. å­é›†

é¢˜ç›®æè¿°ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„Â `nums` ï¼Œæ•°ç»„ä¸­çš„å…ƒç´  **äº’ä¸ç›¸åŒ** ã€‚è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚

è§£é›† **ä¸èƒ½** åŒ…å«é‡å¤çš„å­é›†ã€‚ä½ å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›è§£é›†ã€‚

é¢˜è§£ï¼š

*   é€’å½’

    ```python
    class Solution:
        def subsets(self, nums: List[int]) -> List[List[int]]:
            """
            subset[1,2,3] = subset[1,2] + [[x,3] for x in subset[1,2]]
            """
            if not nums: return [[]]

            last = nums.pop(-1)
            res = self.subsets(nums)

            for i in range(len(res)):
                res.append(res[i]+[last])

            return res

    ```

*   å›æº¯

    ```python
    class Solution:
        def subsets(self, nums: List[int]) -> List[List[int]]: 
            res = []  # éœ€è¦æ‰€æœ‰åˆ†æ”¯çš„ç»“æœ

            def dfs(nums, start, track):
                res.append(track[:])
                for i in range(start, len(nums)):
                    track.append(nums[i])
                    dfs(nums, i+1, track)
                    track.pop(-1)
                return
            
            dfs(nums, 0, [])

            return res

    ```

æ—¶é—´å¤æ‚åº¦ï¼šO(n \* 2^n)ã€‚

ç©ºé—´å¤æ‚åº¦ï¼šO(n)ã€‚å³æ„é€ å­é›†ä½¿ç”¨çš„ä¸´æ—¶æ•°ç»„ t çš„ç©ºé—´ä»£ä»·ã€‚

#### 90. å­é›† II

é¢˜ç›®æè¿°ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ Â `nums` ï¼Œå…¶ä¸­å¯èƒ½åŒ…å«é‡å¤å…ƒç´ ï¼Œè¯·ä½ è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚è§£é›† ä¸èƒ½ åŒ…å«é‡å¤çš„å­é›†ã€‚è¿”å›çš„è§£é›†ä¸­ï¼Œå­é›†å¯ä»¥æŒ‰ ä»»æ„é¡ºåº æ’åˆ—ã€‚

![](image/image_3XHQxlRwH6.png)

```python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()  # å…³é”®

        def dfs(nums, start, track):
            res.append(track[:])
            for i in range(start, len(nums)):
                if i>start and nums[i]==nums[i-1]:  # å…³é”®
                    continue
                track.append(nums[i])
                dfs(nums, i+1, track)
                track.pop(-1)
            return
        
        dfs(nums, 0, [])
        return res
```

# ç»„åˆ

#### 77. ç»„åˆ

é¢˜ç›®æè¿°ï¼šç»™å®šä¸¤ä¸ªæ•´æ•° `n` å’Œ `k`ï¼Œè¿”å›èŒƒå›´ `[1, n]` ä¸­æ‰€æœ‰å¯èƒ½çš„ `k` ä¸ªæ•°çš„ç»„åˆã€‚

é¢˜è§£ï¼šæŒ‰ç…§ä¹‹å‰çš„é¢˜ï¼ŒæŠŠè·¯å¾„ç”»å‡ºæ¥ï¼Œå°±çŸ¥é“è¯¥å¦‚ä½•å‰ªæäº†ã€‚

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        res = []

        def dfs(n, start, track):
            if len(track) == k:
                res.append(track[:])

            for i in range(start, n+1):
                track.append(i)
                dfs(n, i+1, track)
                track.pop(-1)
                

        dfs(n, 1, [])
        return res
```

#### 39. ç»„åˆæ€»å’Œ

é¢˜ç›®æè¿°ï¼šç»™ä½ ä¸€ä¸ª æ— é‡å¤å…ƒç´  çš„æ•´æ•°æ•°ç»„Â candidates å’Œä¸€ä¸ªç›®æ ‡æ•´æ•°Â targetÂ ï¼Œæ‰¾å‡ºÂ candidatesÂ ä¸­å¯ä»¥ä½¿æ•°å­—å’Œä¸ºç›®æ ‡æ•°Â target çš„ æ‰€æœ‰ä¸åŒç»„åˆ ï¼Œå¹¶ä»¥åˆ—è¡¨å½¢å¼è¿”å›ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›è¿™äº›ç»„åˆã€‚

candidates ä¸­çš„ åŒä¸€ä¸ª æ•°å­—å¯ä»¥ æ— é™åˆ¶é‡å¤è¢«é€‰å– ã€‚å¦‚æœè‡³å°‘ä¸€ä¸ªæ•°å­—çš„è¢«é€‰æ•°é‡ä¸åŒï¼Œåˆ™ä¸¤ç§ç»„åˆæ˜¯ä¸åŒçš„ã€‚Â å¯¹äºç»™å®šçš„è¾“å…¥ï¼Œä¿è¯å’Œä¸ºÂ target çš„ä¸åŒç»„åˆæ•°å°‘äº 150 ä¸ªã€‚

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        candidates.sort()

        def dfs(track, start, target):
            if target==0:
                res.append(track[:])
            for i in range(start, len(candidates)):
                if candidates[i] > target: break
                track.append(candidates[i])
                dfs(track, i, target-candidates[i]) # ä»iå¼€å§‹ï¼Œä»£è¡¨å¯ä»¥é‡å¤å–å½“å‰æ•°å€¼
                track.pop(-1)

        dfs([], 0, target)
        
        return res
```

#### 40. ç»„åˆæ€»å’Œ II

é¢˜ç›®æè¿°ï¼š

ç»™ä½ ä¸€ä¸ªç”±å€™é€‰å…ƒç´ ç»„æˆçš„é›†åˆ candidates (å­˜åœ¨é‡å¤å…ƒç´ ) å’Œä¸€ä¸ªç›®æ ‡æ•° target ï¼Œæ‰¾å‡º candidates ä¸­æ‰€æœ‰å¯ä»¥ä½¿æ•°å­—å’Œä¸º target çš„ç»„åˆã€‚

candidates ä¸­çš„æ¯ä¸ªå…ƒç´ åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ ä¸€æ¬¡ ã€‚

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        candidates.sort()
        used = [False] * len(candidates)

        def dfs(track, start, target):
            if target==0:
                res.append(track[:])
            for i in range(start, len(candidates)):
                if candidates[i] > target: break
                if i>0 and candidates[i]==candidates[i-1] and used[i-1]==False:
                    continue
                track.append(candidates[i])        
                used[i] = True
                dfs(track, i+1, target-candidates[i])
                used[i] = False
                track.pop(-1)
        
        dfs([], 0, target)
        return res
```

å¯ä»¥ç”¨startindex æ§åˆ¶ è®©ç»“æœä¸é‡å¤

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        candidates.sort()

        def dfs(track, start, target):
            if target==0:
                res.append(track[:])
            for i in range(start, len(candidates)):
                if candidates[i] > target: break
                if i>start and candidates[i]==candidates[i-1]:
                    continue
                track.append(candidates[i])        
                dfs(track, i+1, target-candidates[i])
                track.pop(-1)
        
        dfs([], 0, target)
        return res
```

#### 216. ç»„åˆæ€»å’Œ III

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        res = []
        def dfs(track, start, target):
            if target==0 and len(track)==k:
                res.append(track[:])
            if len(track)>k or target<0:
                return
            
            for i in range(start, 10):
                # if i in track: continue
                track.append(i)
                dfs(track, i+1, target-i)
                track.pop(-1)
        dfs([], 1, n)
        return res
```

#### 17. ç”µè¯å·ç çš„å­—æ¯ç»„åˆ

å¤šä¸ªé›†åˆæ±‚ç»„åˆ

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits: return []
        res = []
        letter_map = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }
        digits = [letter_map.get(c, "") for c in digits]

        def dfs(digits, start, track):
            if start==len(digits):
                res.append(track)
                return
            
            letters = digits[start]
            for j in letters:
                # ä¸‹åˆ—ä¸‰è¡Œä»£ç ï¼Œç­‰ä»·äºdfs(digits, start+1, track+j)
                track += j
                dfs(digits, start+1, track)
                track = track[:-1]
        
        dfs(digits, 0, "")
        return res
```

# åˆ‡å‰²

#### 131. åˆ†å‰²å›æ–‡ä¸²

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        res = []

        def dfs(track, start):
            if start>=len(s):
                res.append(track[:])
            for i in range(start, len(s)):
                if self._isPalindrome(s[start:i+1]):
                    track.append(s[start:i+1])
                    dfs(track, i+1)
                    track.pop(-1)

        dfs([], 0)

        return res

    def _isPalindrome(self, s: str) -> bool:
        i, j = 0, len(s)-1
        while i<j:
            if s[i]!=s[j]:
                return False
            i, j = i+1, j-1
        return True
```

#### 93. å¤åŸ IP åœ°å€

```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        """
        æ€è·¯ï¼šç ä¸‰åˆ€
        """
        res = []

        def dfs(k, s, start, track):
            if k == 0:
                if is_valid(s[start:]):
                    res.append(".".join(track) + "."+ s[start:])
                return
            
            for i in range(start+1, min(start+4, len(s))):
                if not is_valid(s[start:i]):
                    continue
                track.append(s[start:i])
                dfs(k-1, s, i, track)
                track.pop(-1)

        def is_valid(ip):
            if ip[0] == '0' and ip!='0':
                return False
            if int(ip) > 255:
                return False
            return True

        dfs(3, s, 0, [])
        return res
```

#### 698. åˆ’åˆ†ä¸ºkä¸ªç›¸ç­‰çš„å­é›†

```python
class Solution:
    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        """
        æ€è·¯ï¼šä¸€ä¸ªä¸ªæ¡¶è£…
        """
        if k > len(nums): return False

        sum_ = sum(nums)
        if sum_%k != 0: return False

        target = sum_ / k

        visited = [0] * len(nums)
        
        def backtrace(k, nums, index, target, visited, bucket):
            """
            bucket:å½“å‰æ¡¶ä¸­çš„æ•°æ®å’Œ
            visited:è®°å½•å“ªäº›æ•°æ®å·²ç»ç”¨è¿‡äº†
            """
            if k == 0: return True # æ¯ä¸ªæ¡¶éƒ½è£…å¥½äº†
            
            if bucket == target:
                # è£…ä¸‹ä¸€ä¸ªæ¡¶
                if backtrace(k-1, nums, 0, target, visited, 0):
                    return True

            for i in range(index, len(nums)):
                if visited[i] == 1 or bucket + nums[i] > target:
                    continue
                visited[i] = 1
                bucket += nums[i]
                if backtrace(k, nums, i+1, target, visited, bucket):
                    return True
                bucket -= nums[i]
                visited[i] = 0

            return False

        return backtrace(k, nums, 0, target, visited, 0)
```

# å…¶ä»–

#### 22. æ‹¬å·ç”Ÿæˆ

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []

        def dfs(left, right, track):
            """
            å¯ç”¨çš„å·¦æ‹¬å·æ•°é‡ä¸º left ä¸ªï¼Œå¯ç”¨çš„å³æ‹¬å·æ•°é‡ä¸º rgiht ä¸ª
            """
            if left==0 and right==0:
                res.append(track)
                return

            if right < left: return
            if right < 0 or left < 0: return

            track += '('
            dfs(left-1, right, track)
            track = track[:-1]

            track += ')'
            dfs(left, right-1, track)
            track = track[:-1]
        
        dfs(n, n, "")
        return res
```

#### 491. é€’å¢å­åºåˆ—

é¢˜ç›®æè¿°ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œæ‰¾å‡ºå¹¶è¿”å›æ‰€æœ‰è¯¥æ•°ç»„ä¸­ä¸åŒçš„é€’å¢å­åºåˆ—ï¼Œé€’å¢å­åºåˆ—ä¸­ **è‡³å°‘æœ‰ä¸¤ä¸ªå…ƒç´ ** ã€‚ä½ å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›ç­”æ¡ˆã€‚
æ•°ç»„ä¸­å¯èƒ½å«æœ‰é‡å¤å…ƒç´ ï¼Œå¦‚å‡ºç°ä¸¤ä¸ªæ•´æ•°ç›¸ç­‰ï¼Œä¹Ÿå¯ä»¥è§†ä½œé€’å¢åºåˆ—çš„ä¸€ç§ç‰¹æ®Šæƒ…å†µã€‚

è¾“å…¥ï¼š`nums = [4,6,7,7]`
è¾“å‡ºï¼š`[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]`

```python
class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        """
        è¿™ä¸ªnumsæ˜¯æ— åºçš„ï¼Œä¸”æ±‚å­åºåˆ—ï¼Œä¸èƒ½æ’åºï¼Œæ‰€ä»¥ä¸èƒ½é‡‡ç”¨ä¹‹å‰çš„å»é‡æ–¹æ¡ˆ
        éœ€è¦ä¸€ä¸ªsetè®°å½•è®¿é—®è¿‡çš„æ•°å€¼
        æ³¨æ„ï¼šæ·±åº¦éå†ä¸­æ¯ä¸€å±‚éƒ½ä¼šæœ‰ä¸€ä¸ªå…¨æ–°çš„visitedç”¨äºè®°å½•æœ¬å±‚å…ƒç´ æ˜¯å¦é‡å¤ä½¿ç”¨
        """
        res = []
        len_ = len(nums)

        def dfs(track, start):
            if len(track)>=2:
                res.append(track[:])

            visited = set()
            for i in range(start, len_):
                if (track and nums[i] < track[-1]) or nums[i] in visited:
                    continue
                track.append(nums[i])
                visited.add(nums[i])
                dfs(track, i+1)
                track.pop(-1)
        
        dfs([], 0)
        return res
```

è¿™é“é¢˜å’Œ [47. å…¨æ’åˆ— II](https://leetcode-cn.com/problems/permutations-ii/ "47. å…¨æ’åˆ— II") æ¯”è¾ƒåƒï¼Œåªéœ€è¦åšæ ‘å±‚å»é‡ï¼Œå…è®¸æ ‘æé€‰æ‹©ç›¸åŒæ•°å€¼ã€‚

å¼•å‡º[https://programmercarl.com/å›æº¯ç®—æ³•å»é‡é—®é¢˜çš„å¦ä¸€ç§å†™æ³•.html](https://programmercarl.com/å›æº¯ç®—æ³•å»é‡é—®é¢˜çš„å¦ä¸€ç§å†™æ³•.html# "https://programmercarl.com/å›æº¯ç®—æ³•å»é‡é—®é¢˜çš„å¦ä¸€ç§å†™æ³•.html")

#### 332. é‡æ–°å®‰æ’è¡Œç¨‹

éš¾ç‚¹ï¼š1. é‡‡ç”¨ä»€ä¹ˆæ ·çš„æ•°æ®ç»“æ„å­˜å‚¨æ‰€æœ‰çš„tickets
&#x20;         2\. å¦‚ä½•åˆ é™¤æ¯”è¾ƒåˆé€‚æˆ–è€…æ ‡è®°å·²ç»ç”¨è¿‡çš„ticketï¼ˆä¸åˆ çš„è¯ä¼šæœ‰æ­»å¾ªç¯ï¼‰

```python
from collections import defaultdict

class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        # defaultdic(list) æ˜¯ä¸ºäº†æ–¹ä¾¿ç›´æ¥append
        tickets_dict = defaultdict(list)
        for item in tickets:
            tickets_dict[item[0]].append(item[1])
        '''
        tickets_dicté‡Œé¢çš„å†…å®¹æ˜¯è¿™æ ·çš„
         {'JFK': ['SFO', 'ATL'], 'SFO': ['ATL'], 'ATL': ['JFK', 'SFO']})
        '''
        path = ["JFK"]
        def backtracking(start_point):
            # ç»ˆæ­¢æ¡ä»¶
            if len(path) == len(tickets) + 1:
                return True
            tickets_dict[start_point].sort()
            for _ in tickets_dict[start_point]:
                #å¿…é¡»åŠæ—¶åˆ é™¤ï¼Œé¿å…å‡ºç°æ­»å¾ªç¯
                end_point = tickets_dict[start_point].pop(0)
                path.append(end_point)
                # åªè¦æ‰¾åˆ°ä¸€ä¸ªå°±å¯ä»¥è¿”å›äº†
                if backtracking(end_point):
                    return True
                path.pop()
                tickets_dict[start_point].append(end_point)

        backtracking("JFK")
        return path
```
